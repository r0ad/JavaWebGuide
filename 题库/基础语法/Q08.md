---
outline: deep
---

# 常见基础语法面试题（一）

## Java创建对象有几种方式？

Java中提供了以下四种创建对象的方式:

- new创建新对象
- 通过反射机制
- 采用clone机制
- 通过序列化机制

## 深拷贝和浅拷贝的区别是什么?

浅拷贝: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。

深拷贝: 被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制过的新对象。而不再是原有的那些被引用的对象。换言之。深拷贝把要复制的对象所引用的对象都复制了一遍。

## final有哪些用法?

final也是很多面试喜欢问的地方，通常能回答下以下5点就不错了:

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。
- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率
- 被final修饰的常量，在编译阶段会存入常量池中。

除此之外，编译器对final域要遵守的两个重排序规则更好:

在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

## a=a+b与a+=b有什么区别吗?

`+=` 操作符会**进行隐式自动类型转换**，此处`a+=b`隐式的将加操作的结果类型强制转换为持有结果的类型，而`a=a+b`则不会自动进行类型转换。如：

```java
byte a = 127;
byte b = 127;
b = a + b; // 报编译错误:cannot convert from int to byte
b += a;
```

以下代码是否有错，有的话怎么改？

```java
short s1= 1;
s1 = s1 + 1;
```

有错误。short类型在进行运算时会自动提升为int类型，也就是说 `s1+1` 的运算结果是int类型，而s1是short类型，此时编译器会报错。

正确写法：

```java
short s1= 1;
s1 += 1;
```

## 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

**线程与进程相似**，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

**进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。**系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

## 说说什么是 fail-fast？

fail-fast 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。

例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出ConcurrentModificationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。

解决办法：

建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出 ConcurrentModificationException 异常。
